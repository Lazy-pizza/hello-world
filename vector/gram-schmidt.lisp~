(defun vector-add (v1 v2)
  (map 'vector #'+ v1 v2))

(defun scalar-prod (a v)
  (map 'vector #'* (make-array (length v) :initial-element a) v))
  
(defun inner-prod (v1 v2)
  (reduce #'+ (map 'vector (lambda (x1 x2) (* x1 (conjugate x2))) v1 v2)))

(defun gram-schmidt (vs)
  (labels ((f (basis lst)
	     (if (null lst) basis
		 (let ((head (car lst))
		       (tail (cdr lst)))
		   (if (null basis) (f (append basis (list (scalar-prod
							    (/ 1 (inner-prod
								  head
								  head))
							    head)))
				       tail)
		       (let ((pj (reduce (lambda (tmp u)
					   (vector-add tmp
						       (scalar-prod
							(- (inner-prod
							    head
							    u))
							u)))
					 basis :initial-value head)))
			 (f (append basis (list (scalar-prod
						 (/ 1 (inner-prod
						       pj
						       pj))
						 pj)))
			    tail)))))))
    (f '() vs)))
					   
  
