;; ***** NUMBER-GCD *****

;; functions for calculate (x_1,...x_n) satisfying
;; a_1x_1 + a_2x_2 + ... + a_nx_n = d
;; and give d = gcd(a_1,...a_n)

(defun rev-gcd (a b)
  (labels ((f (a b s1 s2)
	     (cond ((< a b) (f b a s2 s1))
		   ((< b 0) (f a (- b) s1 (cons (- (car s2)) (- (cdr s2)))))
		   ((= b 0) (make-gcdsol :gcd a
					 :sol s1))
		   (t (multiple-value-bind (q r) (floor a b)
					  (f b
					     r
					     s2
					     (cons (- (car s1) (* q (car s2)))
						   (- (cdr s1) (* q (cdr s2))))
					     ))))))
    (f a b (cons 1 0) (cons 0 1))))

(defun rev-gcd-lst (lst)
  (let ((sollst (reverse (reduce (lambda (tmp x)
				   (if (null tmp)
				       (cons (rev-gcd 0 x) tmp)
				       (cons (rev-gcd (gcdsol-gcd (car tmp))
						      x)
					     tmp )))
				 lst
						      :initial-value '()))))
    (labels ((g (lst)
	       (if (null lst) '()
		   (let ((head (car lst))
			 (tail (cdr lst)))
		     (cons (* (reduce (lambda (tmp x)
					(* (car (gcdsol-sol x)) tmp))
				      tail
					:initial-value 1)
			      (cdr (gcdsol-sol head)))
			   (g tail))))))
	   (make-gcdsol
	    :gcd (gcdsol-gcd (car (last sollst)))
	    :sol (g sollst)))))

;; mutually-primep

(defun mutually-primep (xs)
  (labels ((f (a lst)
	     (null (remove-if (lambda (x) (= 1 (gcd a x))) lst))))
    (or (null xs)
	(let ((head (car xs))
	      (tail (cdr xs)))
	  (and (f head tail) (mutually-primep tail))))))

;; relative-prime-converter
;; take n integers and make them to be relative primes to each other

(defun convert-to-mutually-prime (xs)
  (labels ((f (lst a)
	     (if (null lst) (list a)
		 (let* ((head (car lst))
			(tail (cdr lst))
			(d (gcd a head)))
		   (cons (/ head d) (f tail (/ a d))))))
	   (g (lst xs)
	     (if (null xs) lst
		 (let ((head (car xs))
		       (tail (cdr xs)))
		   (g (f lst head) tail)))))
    (g '() xs)))

;; ***** NUMBER-GCD END *****
